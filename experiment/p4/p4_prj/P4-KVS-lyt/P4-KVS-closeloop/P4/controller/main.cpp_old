//
// Created by Alex_Li on 2022/7/10.
//

#include <iostream>
#include <unistd.h>
#include <unordered_set>
#include <fstream>
#include <iomanip>

#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <net/if.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/filter.h>
#include <arpa/inet.h>

#include "config.h"
#include "my_header.h"
#include "p4_program.h"
#include "p4_table.h"

using namespace std;

void usage()
{
	const string basename = "hello_bfrt";
	cout << "USAGE: << " << basename << " {-p <...> | -c <...>} [OPTIONS -- SWITCHD_OPTIONS]" << '\n'
	     << "Options for running switchd:" << '\n'
	     << "  -p <p4_program_name>" << '\n'
	     << "    Load driver with artifacts associated with P4 program" << '\n'
	     << "  -c TARGET_CONFIG_FILE" << '\n'
	     << "    TARGET_CONFIG_FILE that describes P4 artifacts of the device" << '\n'
	     << "  -r REDIRECTLOG" << '\n'
	     << "    logfile to redirect" << '\n'
	     << "  -C" << '\n'
	     << "    Start CLI immediately" << '\n'
	     << "  --skip-p4" << '\n'
	     << "    Skip loading of P4 program in device" << '\n'
	     << "  --skip-hld <skip_hld_mgr_list>" << '\n'
	     << "    Skip high level drivers:" << '\n'
	     << "    p:pipe_mgr, m:mc_mgr, k:pkt_mgr, r:port_mgr, t:traffic_mgr" << '\n'
	     << "  --skip-port-add" << '\n'
	     << "    Skip adding ports" << '\n'
	     << "  --kernel-pkt" << '\n'
	     << "    use kernel space packet processing" << '\n'
	     << "  -h" << '\n'
	     << "    Print this message" << '\n'
	     << "  -g" << '\n'
	     << "    Run with gdb" << '\n'
	     << "  --gdb-server" << '\n'
	     << "    Run with gdbserver; Listening on port 12345 " << '\n'
	     << "  --no-status-srv" << '\n'
	     << "    Do not start bf_switchd's status server" << '\n'
	     << "  --status-port <port number>" << '\n'
	     << "    Specify the port that bf_switchd's status server will use; the default is 7777" << '\n'
	     << "  -s" << '\n'
	     << "    Don't stop on the first error when running under the address sanitizer" << '\n'
	     << "  --init-mode <cold|fastreconfig>" << '\n'
	     << "    Specify if devices should be cold booted or under go fast reconfig" << '\n'
	     << "  --arch <Tofino|Tofino2>" << '\n'
	     << "    Specify the chip architecture, defaults to Tofino" << '\n'
	     << "  --server-listen-local-only" << '\n'
	     << "    Servers can only be connected from localhost" << endl;
}

int main(int argc, char **argv)
{
	string program_name;
	bool debug = false;
	int begin = 0;
	int end = 0;

	// parse option
	{
		int o;
		while((o = getopt(argc, argv, "p:b:e:d")) != -1)
		{
			switch(o)
			{
				case 'p':
					program_name = optarg;
					break;
				case 'd':
					debug = true;
					break;
				case 'b':
					begin = stoi(optarg);
					break;
				case 'e':
					end = stoi(optarg);
					break;
				case '?':
					usage();
					return 0;
				default:
					return 0;
			}
		}

		if(program_name.empty())
		{
			usage();
			return 0;
		}
	}

	P4Program program(program_name);

	// config forwarding
	{
		cout << "Initiating hash partition table..." << endl;

		auto &forward = program.getTable("Ingress.hash_partition_forward");

		auto lock_id_key_id = forward.getKey("hdr.lock.lock_id");
		auto send_action_id = forward.getAction("Ingress.send");
		auto send_action_port_data_id = forward.getData("port", "Ingress.send");

		// (_) : send(20) // 19/-
		forward.keyHandlerReset();
		forward.keyHandlerSetValueAndMask(lock_id_key_id, 0, 0);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 20);
		forward.tableEntryAdd();
	}

	// config ip/arp forwarding
	{
		cout << "Initiating ipv4 forward table..." << endl;

		auto &forward = program.getTable("Ingress.ipv4_host");

		auto dst_ipv4_key_id = forward.getKey("meta.dst_ipv4");
		auto send_action_id = forward.getAction("Ingress.send");
		auto send_action_port_data_id = forward.getData("port", "Ingress.send");

		// 10.0.0.1   -> 11/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.1"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 40); // 11/-
		forward.tableEntryAdd();

		// 10.0.0.2   -> 12/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.2"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 32); // 12/-
		forward.tableEntryAdd();

		// 10.0.0.3   -> 13/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.3"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 24); // 13/-
		forward.tableEntryAdd();

		// 10.0.0.4   -> 14/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.4"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 16); // 14/-
		forward.tableEntryAdd();

		// 10.0.0.7   -> 17/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.7"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t)  4); // 17/-
		forward.tableEntryAdd();

		// 10.0.0.8   -> 18/- client
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.8"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 12); // 18/-
		forward.tableEntryAdd();

		// 10.0.0.235 -> 19/- FPGA data port 0
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("10.0.0.235"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 20); // 19/-
		forward.tableEntryAdd();

		// 192.168.189.34 -> cpu port
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_ipv4_key_id, inet_network("192.168.189.34"));
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 192);
		forward.tableEntryAdd();
	}

	// config mac forwarding
	{
		cout << "Initiating mac forward table..." << endl;

		auto &forward = program.getTable("Ingress.mac_forward");

		auto dst_addr_key_id = forward.getKey("hdr.ethernet.dst_addr");
		auto send_action_id = forward.getAction("Ingress.send");
		auto send_action_port_data_id = forward.getData("port", "Ingress.send");

		// 14/- cpu control
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_addr_key_id, 0x98039bc7c0a8);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 16); // 14/-
		forward.tableEntryAdd();

		// 16/- cpu control
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_addr_key_id, 0x98039bc7c7fc);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 0); // 16/-
		forward.tableEntryAdd();

		// 17/- cpu control
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_addr_key_id, 0x98039bca4018);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 4); // 17/-
		forward.tableEntryAdd();

		// 18/- cpu control
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_addr_key_id, 0x0c42a12b0d70);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 12); // 18/-
		forward.tableEntryAdd();

		// 24/- FPGA control port
		forward.keyHandlerReset();
		forward.keyHandlerSetValue(dst_addr_key_id, 0x000a35029de9);
		forward.dataHandlerReset(send_action_id);
		forward.dataHandlerSetValue(send_action_port_data_id, (uint64_t) 60); // 24/-
		forward.tableEntryAdd();
	}

	// config ports and mirroring
	{
		cout << "Initiating ports..." << endl;

		// client
		program.portAdd("11/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("12/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("13/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("14/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("15/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("16/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("17/0", BF_SPEED_100G, BF_FEC_TYP_RS);
	    program.portAdd("18/0", BF_SPEED_100G, BF_FEC_TYP_RS);

		program.configMirroring(1, 40); // 11/-
		program.configMirroring(2, 32); // 12/-
		program.configMirroring(3, 24); // 13/-
		program.configMirroring(4, 16); // 14/-
		program.configMirroring(5,  8); // 15/-
		program.configMirroring(6,  0); // 16/-
		program.configMirroring(7,  4); // 17/-
		program.configMirroring(8, 12); // 18/-

		// controller
		program.portAdd("19/0", BF_SPEED_100G, BF_FEC_TYP_NONE, PM_AN_FORCE_DISABLE); // dev port 20, FPGA port 0 data
		program.portAdd("24/0", BF_SPEED_100G, BF_FEC_TYP_NONE, PM_AN_FORCE_DISABLE); // dev port 60, FPGA port 1 control

		program.configMirroring(9, 60); // 24/- FPGA controller
//		program.configMirroring(9, 0); // 16/- cpu controller

		// test
//		program.configMirroring(1, 192);
//		program.configMirroring(9, 192);
	}

	// init network
	int sock_fd;
	sockaddr_ll sl{};
	{
		cout << "Initiating network..." << endl;

		sock_fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
		if(-1 == sock_fd)
		{
			cout << "Create socket error(" << errno << "): " << strerror(errno) << endl;
			return -1;
		}

		ifreq ifr{};
		bzero(&ifr, sizeof(ifr));
		strcpy(ifr.ifr_name, "enp6s0");

		/* set promiscuous */
		ioctl(sock_fd, SIOCGIFFLAGS, &ifr);
		ifr.ifr_flags |= IFF_PROMISC;
		ioctl(sock_fd, SIOCSIFFLAGS, &ifr);
		ioctl(sock_fd, SIOCGIFINDEX, &ifr);

		bzero(&sl, sizeof(sl));
		sl.sll_family = PF_PACKET;
		sl.sll_protocol = htons(ETH_P_ALL);
		sl.sll_ifindex = ifr.ifr_ifindex;

		if(-1 == bind(sock_fd, (sockaddr *) &sl, sizeof(sl)))
		{
			cout << "Bind error(" << errno << "): " << strerror(errno) << endl;
			return -1;
		}

		sock_fprog filter{};
		sock_filter code[] = { // tcpdump -dd ether proto 0x2333 -s 0
				{0x28, 0, 0, 0x0000000c},
				{0x15, 0, 1, 0x00002333},
				{0x6,  0, 0, 0x00040000},
				{0x6,  0, 0, 0x00000000},
		};

		filter.len = sizeof(code) / sizeof(sock_filter);
		filter.filter = code;

		if(-1 == setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter)))
		{
			cout << "Set socket option error(" << errno << "): " << strerror(errno) << endl;
			return -1;
		}
	}

	// lock function
	auto &mapping = program.getTable("Ingress.index_mapping_table");
	auto lock_id_key_id = mapping.getKey("hdr.lock.lock_id");
	auto mapping_action_id = mapping.getAction("Ingress.mapping");
	auto mapping_action_mapped_index_data_id = mapping.getData("index", "Ingress.mapping");

	auto &suspend = program.getTable("Ingress.suspend_flag_reg");
	auto suspend_index_id = suspend.getKey("$REGISTER_INDEX");
	auto suspend_data_id = suspend.getData("Ingress.suspend_flag_reg.f1");

	// init entries
	unordered_map<uint32_t, uint32_t> index_mapping;
	unordered_map<uint32_t, uint32_t> reverse_mapping;
	{
		cout << "Initiating mapping..." << endl;
		cout << "Init lock from lock id " << begin << " to lock id " << end << endl;

		program.beginBatch();
		for(uint64_t i = begin; i < end; ++i)
		{
			uint32_t id = i;
			uint32_t index = i;

			index_mapping[id] = index;
			reverse_mapping[index] = id;

			mapping.keyHandlerReset();
			mapping.keyHandlerSetValue(lock_id_key_id, reverse_mapping[i]);
			mapping.dataHandlerReset(mapping_action_id);
			mapping.dataHandlerSetValue(mapping_action_mapped_index_data_id, i);
			mapping.tableEntryAdd();
		}
		program.endBatch(true);
	}

	// init precise counter
	vector<P4Table*> precise_counter;
	vector<bf_rt_id_t> precise_counter_index_id;
	vector<bf_rt_id_t> precise_counter_data_id;
	{
		cout << "Initiating precise counter..." << endl;

		for(int i = 0; i < 8; ++i)
		{
			precise_counter.push_back(&program.getTable("counter_bucket_reg_" + to_string(i)));
			precise_counter_index_id.push_back(precise_counter[i]->getKey("$REGISTER_INDEX"));
			precise_counter_data_id.push_back(precise_counter[i]->getData("Ingress.counter_bucket_reg_" + to_string(i) + ".f1"));
		}
	}

	// begin sniff
	cout << "-----------------------------------\n"
	     << "Service begin" << endl;

	ofstream file;
	if(debug)
	{
		auto time = std::time(nullptr);
		ostringstream ss;
		ss << put_time(std::localtime(&time), "%Y%m%d%H%M");
		string filename = "/root/Projects/test/log/replacement_" + ss.str() + ".log";
		file.open(filename);
		if(!file)
		{
			cout << "Fail to open file " << filename << endl;
			return -1;
		}
	}

	u_char pkt_data[1024];
	while(true)
	{
		auto len = recvfrom(sock_fd, pkt_data, sizeof(pkt_data), 0, nullptr, nullptr);
		if(-1 == len)
		{
			cout << "Receive error(" << errno << "): " << strerror(errno) << endl;
			continue;
		}

		auto *lock_ctl_header = (LOCK_CTL_HEADER *) (pkt_data + 14);
		if(lock_ctl_header->op == HOT_REPORT)
		{
			int n = lock_ctl_header->replace_num;
			int e = 0;

			if(debug) file << "Receive " << n << " hot lock" << endl;

			for(int i = 0; i < n && i < 8; ++i)
			{
				uint64_t id = ntohl(lock_ctl_header->id[i]);
				uint64_t index = ntohl(lock_ctl_header->index[i]);
				uint64_t counter = ntohl(lock_ctl_header->counter[i]);

				if(index >= SLOT_SIZE)
				{
					if(debug) file << "{" << id << ", " << index << "}: index error" << endl;
					continue;
				}

				auto index_iter = index_mapping.find(id);
				if(index_iter == index_mapping.cend())
				{
					auto reverse_iter = reverse_mapping.find(index);
					if(reverse_iter != reverse_mapping.cend())
					{
						index_mapping.erase(reverse_iter->second);

						mapping.keyHandlerReset();
						mapping.keyHandlerSetValue(lock_id_key_id, reverse_iter->second);
						mapping.tableEntryDelete();
						mapping.completeOperations();

						if(debug) file << "{" << reverse_iter->second << ", " << index << "} ==> ";
					}
//				    else if(reverse_mapping.size() < SLOT_SIZE)
//				    {
//				    	index = reverse_mapping.size();
//				    }

					index_mapping[id] = index;
					reverse_mapping[index] = id;

					// mapping.modifyEntry(make_tuple(index, id));
					mapping.keyHandlerReset();
					mapping.keyHandlerSetValue(lock_id_key_id, id);
					mapping.dataHandlerReset(mapping_action_id);
					mapping.dataHandlerSetValue(mapping_action_mapped_index_data_id, index);
					mapping.tableEntryAdd();
					mapping.completeOperations();

					precise_counter[index % 8]->keyHandlerReset();
					precise_counter[index % 8]->keyHandlerSetValue(precise_counter_index_id[index % 8], index / 8);
					precise_counter[index % 8]->dataHandlerReset();
					precise_counter[index % 8]->dataHandlerSetValue(precise_counter_data_id[index % 8], counter);
					precise_counter[index % 8]->tableEntryModify();
					precise_counter[index % 8]->completeOperations();

					if(debug) file << "{" << id << ", " << index << "}" << endl;
				}
				else
				{
					if(debug) file << "{" << id << ", " << index_iter->second << "} <=> {" << id << ", " << index << "}" << endl;
					e++;
				}

				// suspend.modifyEntry(index, 0);
				suspend.keyHandlerReset();
				suspend.keyHandlerSetValue(suspend_index_id, index);
				suspend.dataHandlerReset();
				suspend.dataHandlerSetValue(suspend_data_id, (uint64_t) 0);
				suspend.tableEntryModify();
				suspend.completeOperations();
			}

			auto *ether_header = (ETH_HEADER *) pkt_data;
			swap(ether_header->DestMac, ether_header->SrcMac);
			lock_ctl_header->op = REPLACE_SUCC;
			auto r = sendto(sock_fd, pkt_data, len < 64 ? len : 64, 0, (sockaddr *) &sl, sizeof(sl));
			if(r < 0)
			{
				cout << "error" << endl;
				break;
			}

//			if(debug) cout << "Successfully handle " << n - e << " hot replace request" << endl;
		}
	}

	if(debug) file.close();

	return 0;
}
